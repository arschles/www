---
author: "Aaron Schlesinger"
date: 2020-11-19T14:26:41-08:00
title: 'KEDA and KEDA-HTTP for Webapps'
slug: 'k8s-webapps-easy-button'

# For twitter cards, see https://github.com/mtn/cocoa-eh-hugo-theme/wiki/Twitter-cards
# meta_img = "/images/image.jpg"

# For hacker news and lobsters builtin links, see github.com/mtn/cocoa-eh-hugo-theme/wiki/Social-Links
# hacker_news_id = ""
# lobsters_id = ""
---

When you search for ["what is Kubernetes?"](https://duckduckgo.com/?q=what+is+kubernetes&t=brave&ia=web), content abounds with technical details of the system. There's less about what Kubernetes is at a high level. Here's my attempt at that in two sentences:

>Kubernetes is an operating system for your cluster of computers. Like any OS, you get a syscall API for CPU, memory, networking, storage and more, and build abstractions from there.

If you're new to Kubernetes, take the time to let those two sentences sink in before you move on to technical details, especially if your goal is to run your applications on Kubernetes. Much of the content and state of the art in the community is oriented toward people trying to _operate Kubernetes clusters_.

## App Developers on the Web

I'm using the term "app developer" in a very imprecise way; that's on purpose. I'm not out to define what this group developers does or is, I'm out to assert the tasks they _shouldn't have to do_ while building their app. Developers should not have to understand or think about the details of virtual machines, the Kubelet, `Pod`s/`Deployment`s/`Service`s/etc..., or `kubectl` [0]. They also shouldn't need to invoke [Helm](https://helm.sh) charts or watch Kubernetes dashboards after a deploy [1]. In other words, they shouldn't have to know the syscall API to accomplish everyday tasks.

Kubernetes is a robust platform on which to run web applications, not an adequate experience for web developers to deploy them.

## A Better Experience

In 2015, Rob Pike gave a talk at dotGo entitled ["Simplicity is Complicated"](https://www.youtube.com/watch?v=rFejpH_tAHM). Referring to the Go language, he explained that while Go looks simple to developers, the code that implements that simplicity is very complex. Indeed, the Go standard library provides a very _simple_ and _flexible_ API to access the underlying system.

Kubernetes is the underlying system in our world. We have several frameworks that expose it in a simple but relatively inflexible way [2]. The task we have is (a) definiting what a simple and flexible interface needs to look like, and (b) implementing it.

Many cloud providers have relevant products we can draw inspiration from [3]. While these platforms are diverse, most or all of them have the following rough features in common:

- You _focus_ on running your code, not underlying resources like VMs or containers
- Your code can scale up and down based on demand
- A CLI is available to deploy your code to production with a command
- Your app can built in the cloud
- It's easy to connect your code to other databases and other cloud services
- You can opt in to advanced features like gradual rollouts and more

Kubernetes has the foundational technologies that can build these higher level features. Our challenge is to choose the right ones and build a simple and flexible interface with which developers can interact.

## KEDA HTTP

That brings us to [KEDA-HTTP](https://github.com/osscda/kedahttp), a new project I'm starting. I'm building KEDA-HTTP to bring Kubernetes closer "webapp developers" by abstracting over the syscalls and exposing the right features for developers.

### Under the Hood

The project invents almost no new technology, preferring to assemble existing building blocks to build the right user experience (UX):

- Standard Kubernetes `Deployment`s, `Service`s and `Ingress`es and Ingress Controllers for running pods ("compute") and routing HTTP traffic to them
- [KEDA](https://keda.sh) for scaling `Deployment`s up and down
- The [operator pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) and [Custom Resource Definitions (CRDs)](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) for defining a comprehensive abstraction and API over KEDA and the standard Kubernetes resources

Personally, I'm excited about the fact that the project is partially being implemented in [Rust](https://rust-lang.org).

### The Future

Kubernetes has democratized distributed systems for developers. Distributed primitives like leader election, bin packing and locking/leasing are exposed in a uniform API. Any developer can access it, but doing so requires reading and understanding several long documents; that requirement alone is a barrier to entry for a lot of people.

I believe that we know what the aforementioned simple and flexible system needs to look like. As I see this system evolve, I'm optimistic that this next level of abstraction will double the number of developers who can use the technology.

Work is ongoing in [github/osscda/kedahttp](https://github.com/osscda/kedahttp), and there is a [proposal](https://github.com/kedacore/keda/issues/538) open for adding this technology to the KEDA project, which will help make it available to a larger audience.

A small team of myself, my Cloud Advocate peers at Microsoft, and the great people in the KEDA project are working on this project. We're not quite ready for help, but watch the [proposal issue](https://github.com/kedacore/keda/issues/538) for progress. We'll be slowly modularizing the codebase and contributing functionality piece by piece into KEDA.

---
[0] As is the case with every abstraction, developers should somewhat understand inner workings.
[1] In many cases, developers also function in SRE or DevOps roles as well. In those situations, they almost certainly would need to use these dashboards to assess the health of their code in production. There is a clear separation of roles or "personas" implied here - the developer writes application code and deploys it to production, while the SRE/DevOps engineer operates it in production.
[2] Several high quality Functions As A Service (FaaS) frameworks are purpose-built for Kubernetes. They offer a single-command deployment system along with automatic scaling and several other features that many developers need, but they lack features that are out of scope for the standard FaaS architecture.
[3]  In no order, with no preference and non-exhaustively, these include [App Platform](https://www.digitalocean.com/products/app-platform/), [App Engine](https://cloud.google.com/appengine/), [Elastic Beanstalk](https://aws.amazon.com/elasticbeanstalk/), [Heroku](https://heroku.com) and [App Service](https://azure.microsoft.com/en-us/services/app-service/)
